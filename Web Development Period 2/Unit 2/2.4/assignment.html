<!DOCTYPE html>
<html>
<head>
  <title>Cipher Tool</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    #mapping { display: flex; flex-wrap: wrap; gap: 6px; margin: 8px 0; }
    .tile { border: 1px solid #ccc; padding: 4px 6px; width: 42px; text-align: center; }
    textarea { width: 100%; max-width: 700px; }
    .row { margin: 8px 0; }
  </style>
</head>
<body>
  <h1>Ciphers + DOM</h1>

  <div class="row">
    <label>Type:</label>
    <select id="cipherType">
      <option value="caesar">Caesar (Shift)</option>
      <option value="substitution">Substitution (Mapping)</option>
    </select>

    <label for="shift">Shift:</label>
    <input id="shift" type="number" value="3" style="width:60px">
  </div>

  <div class="row">
    <button id="genCipher">Generate New Cipher</button>
    <input id="loadInput" type="text" placeholder="Enter 26-letter mapping (e.g. QWERTY...)" style="width:320px">
    <button id="loadCipher">Load Cipher</button>
    <span id="errorMsg" style="color:red; margin-left:8px;"></span>
  </div>

  <h3>Current Mapping</h3>
  <div id="mapping"></div>

  <h3>Encrypt / Decrypt</h3>
  <div class="row">
    <textarea id="inputMsg" rows="4" cols="60" placeholder="Enter text..."></textarea>
  </div>
  <div class="row">
    <button id="encryptBtn">Encrypt</button>
    <button id="decryptBtn">Decrypt</button>
  </div>
  <div class="row">
    <textarea id="outputMsg" rows="4" cols="60" readonly placeholder="Output appears here..."></textarea>
  </div>

  <script>
    // ----- your style: constants and helpers -----
    const alphabet = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"];
    const ALPHABET_LENGTH = 26;

    const isCapitalLetter = (characterString) => {
      return (characterString.length === 1 && characterString >= "A" && characterString <= "Z");
    };

    const returnCapitalLetter = (characterString) => {
      return characterString.toUpperCase();
    };

    const isLowercaseLetter = (characterString) => {
      return (characterString.length === 1 && characterString >= "a" && characterString <= "z");
    };

    const shiftLogic = (initialIndex, shift) => {
      return ((initialIndex + shift) % 26 + 26) % 26;
    };

    const alphabetLetter = (characterString) => {
      if (characterString.length !== 1) return false;
      const ch = characterString.toLowerCase();
      return alphabet.indexOf(ch) !== -1;
    };

    // find original key by value in a plain object map
    const getOriginalValue = (map, searchValue) => {
      const keys = Object.keys(map);
      for (let i = 0; i < keys.length; i++) {
        const k = keys[i];
        if (map[k] === searchValue) {
          return k;
        }
      }
      return undefined;
    };

    // ----- Caesar -----
    function caesarCipher(message, shift){
      let finalString = "";
      for(let ind = 0; ind < message.length; ind++){
        const ch = message[ind];

        if(isCapitalLetter(ch)) {
          let initIndex = alphabet.indexOf(ch.toLowerCase());
          if (initIndex === -1) {
            finalString += ch;
          } else {
            let finalindex = shiftLogic(initIndex, shift);
            finalString += returnCapitalLetter(alphabet[finalindex]);
          }
          continue;
        } else if(isLowercaseLetter(ch)) {
          let initIndex = alphabet.indexOf(ch);
          if (initIndex === -1) {
            finalString += ch;
          } else {
            let finalindex = shiftLogic(initIndex, shift);
            finalString += alphabet[finalindex];
          }
        } else {
          finalString += ch;
        }
      }
      return finalString;
    }

    function caesarDecode(message, shift){
      let finalString = "";
      for(let ind = 0; ind < message.length; ind++){
        const ch = message[ind];

        if(isCapitalLetter(ch)) {
          let initIndex = alphabet.indexOf(ch.toLowerCase());
          if (initIndex === -1) {
            finalString += ch;
          } else {
            let finalindex = shiftLogic(initIndex, -shift);
            finalString += returnCapitalLetter(alphabet[finalindex]);
          }
          continue;
        } else if(isLowercaseLetter(ch)) {
          let initIndex = alphabet.indexOf(ch);
          if (initIndex === -1) {
            finalString += ch;
          } else {
            let finalindex = shiftLogic(initIndex, -shift);
            finalString += alphabet[finalindex];
          }
        } else {
          finalString += ch;
        }
      }
      return finalString;
    }

    // ----- Substitution -----
    function generateCipher(){
      const letters = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"];
      let currentIndex = letters.length;
      let randomIndex;

      while (currentIndex !== 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        const tmp = letters[currentIndex];
        letters[currentIndex] = letters[randomIndex];
        letters[randomIndex] = tmp;
      }

      const cipherMap = {};
      for(let ind = 0; ind < ALPHABET_LENGTH; ind++){
        cipherMap[alphabet[ind]] = letters[ind];
      }

      return cipherMap;
    }

    function substitutionCipher(message, cipherMap){
      let finalString = "";
      for(let ind = 0; ind < message.length; ind++){
        const ch = message[ind];

        if(isCapitalLetter(ch)) {
          let lowerChar = ch.toLowerCase();
          let mapped = cipherMap[lowerChar];
          if(mapped) {
            finalString += returnCapitalLetter(mapped);
          } else {
            finalString += ch;
          }
          continue;
        } else if(isLowercaseLetter(ch)) {
          let mapped = cipherMap[ch];
          if(mapped) {
            finalString += mapped;
          } else {
            finalString += ch;
          }
        } else {
          finalString += ch;
        }
      }
      return finalString;
    }

    function substitutionDecode(message, cipherMap){
      let finalString = "";
      for(let ind = 0; ind < message.length; ind++){
        const ch = message[ind];

        if(isCapitalLetter(ch)) {
          let lowerChar = ch.toLowerCase();
          let original = getOriginalValue(cipherMap, lowerChar);
          if(original) {
            finalString += returnCapitalLetter(original);
          } else {
            finalString += ch;
          }
          continue;
        } else if(isLowercaseLetter(ch)) {
          let original = getOriginalValue(cipherMap, ch);
          if(original) {
            finalString += original;
          } else {
            finalString += ch;
          }
        } else {
          finalString += ch;
        }
      }
      return finalString;
    }

    // ----- DOM + State -----
    let currentCipher = null; // object like { a: 'q', b: 'z', ... }

    const renderMapping = (map) => {
      const container = document.querySelector("#mapping");
      container.innerHTML = "";

      if (!map) {
        return;
      }

      for (let i = 0; i < ALPHABET_LENGTH; i++) {
        const from = alphabet[i];
        const to = map[from];
        const tile = document.createElement("div");
        tile.className = "tile";
        if (to) {
          tile.textContent = from.toUpperCase() + "→" + to.toUpperCase();
        } else {
          tile.textContent = from.toUpperCase() + "→?";
        }
        container.appendChild(tile);
      }
    };

    // Generate new substitution mapping
    document.querySelector("#genCipher").onclick = function() {
      const type = document.querySelector("#cipherType").value;
      const err = document.querySelector("#errorMsg");

      if (type === "substitution") {
        currentCipher = generateCipher();
        renderMapping(currentCipher);
        err.textContent = "";
      } else {
        err.textContent = "Caesar uses only the numeric shift.";
      }
    };

    // Load mapping from text
    document.querySelector("#loadCipher").onclick = function() {
      const txt = document.querySelector("#loadInput").value.trim().toLowerCase();
      const err = document.querySelector("#errorMsg");

      if (txt.length !== 26) {
        err.textContent = "Error: Must be exactly 26 letters.";
        return;
      }

      for (let i = 0; i < txt.length; i++) {
        const ch = txt[i];
        if (!isLowercaseLetter(ch)) {
          err.textContent = "Error: Only letters a-z are allowed.";
          return;
        }
      }

      const seen = {};
      for (let i = 0; i < txt.length; i++) {
        const ch = txt[i];
        if (seen[ch]) {
          err.textContent = "Error: No duplicate letters allowed.";
          return;
        }
        seen[ch] = true;
      }

      const map = {};
      for (let i = 0; i < ALPHABET_LENGTH; i++) {
        map[alphabet[i]] = txt[i];
      }

      currentCipher = map;
      err.textContent = "";
      renderMapping(currentCipher);
    };

    // Encrypt
    document.querySelector("#encryptBtn").onclick = function() {
      const type = document.querySelector("#cipherType").value;
      const shiftInput = document.querySelector("#shift").value;
      const msg = document.querySelector("#inputMsg").value;
      let out = "";

      if (type === "caesar") {
        const shift = parseInt(shiftInput);
        out = caesarCipher(msg, isNaN(shift) ? 0 : shift);
      } else {
        if (currentCipher) {
          out = substitutionCipher(msg, currentCipher);
        } else {
          out = "No substitution cipher loaded.";
        }
      }

      document.querySelector("#outputMsg").value = out;
    };

    // Decrypt
    document.querySelector("#decryptBtn").onclick = function() {
      const type = document.querySelector("#cipherType").value;
      const shiftInput = document.querySelector("#shift").value;
      const msg = document.querySelector("#inputMsg").value;
      let out = "";

      if (type === "caesar") {
        const shift = parseInt(shiftInput);
        out = caesarDecode(msg, isNaN(shift) ? 0 : shift);
      } else {
        if (currentCipher) {
          out = substitutionDecode(msg, currentCipher);
        } else {
          out = "No substitution cipher loaded.";
        }
      }

      document.querySelector("#outputMsg").value = out;
    };

    // initial render
    renderMapping(null);
  </script>
</body>
</html>
