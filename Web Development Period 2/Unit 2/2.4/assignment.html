<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Assingment 2.4</title>
    <style>
        .mapping {
            display: flex;
        }
        textarea {
            width: 300px;
            height: 100px;
        }
    </style>
</head>
<body>
    <h1>Assingment 2.4</h1>
    <label>Whether you want a subtitution or a caesar cipher with shifts:
        <select id="chosenCiph">
            <option value="caesar">Caesar(Shift) Cipher</option>
            <option value="substitution">Substitution Cipher</option>
        </select>
    </label>
    <label>Shift: <input id="shift" type="number" value="3"></label>
    <br>

    <button id="genBtn">Generate Cipher</button>
    <input id="loadInput" type="text" placeholder="Now here you can determine which letter is assigned to what">
    <button id="loadBtn">Load Cipher</button>
    <span id="error" style="color:red"></span>

    <div id="mapping" class="mapping"></div>

    <h3>Here input what you want to encrypt or decrypt:</h3>
    <textarea id="plain"></textarea><br>
    <button id="encBtn">Encrypt to transform into a secret code</button>
    <button id="decBtn">Decrypt to see what the secret code says</button><br>
    <textarea id="answer" readonly></textarea>

    <script>
    
        const alphabet = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"];
        const ALPHABET_LENGTH = 26;
        const upperAllAlpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        const isCapitalLetter =(cStr) =>
        {
          return ( cStr.length === 1 && cStr >= "A" && cStr <= "Z");
        };

        const returnCapitalLetter = (cStr) =>
        {
            return cStr.toUpperCase();
        };

        const isLowercaseLetter = (cStr) =>
        {
            return (cStr.length === 1 && cStr >= "a" && cStr <= "z");
        };

        const shiftLogic=(initialIndex, shift) =>
        {
            return ((initialIndex + shift) % ALPHABET_LENGTH + ALPHABET_LENGTH) % ALPHABET_LENGTH;
        };

        const getOriginalValue = (map, searchValue) => {
            for (let [key, value] of map.entries()) {
                if (value === searchValue) {
                    return key;
                }
            }
            return undefined;
        }

        
        let currentCipher = {};  
        let lowMapping = null;       

        function updateDisplay() {
            const div = document.querySelector("#mapping");
            div.innerHTML = "";
            for (let i = 0; i < upperAllAlpha.length; i++) {
                const ch = upperAllAlpha[i];
                const tile = document.createElement("div");
                tile.className = "tile";
                const mapped = currentCipher[ch];
                if (mapped) {
                    tile.textContent = ch + "→" + mapped;
                } else {
                    tile.textContent = ch + "→" + ch;
                }
                div.appendChild(tile);
            }
        }

        // ===== embed your logic directly inside the handlers =====

        // Generate (uses your shift logic for Caesar, your Fisher–Yates for Substitution)
        function generateCipher() {
            const type = document.querySelector("#chosenCiph").value;

            if (type === "caesar") {
                let shift = parseInt(document.querySelector("#shift").value, 10);
                if (isNaN(shift)) {
                    shift = 0;
                }

                currentCipher = {};
                for (let i = 0; i < 26; i++) {
                    let idx = shiftLogic(i, shift);
                    currentCipher[upperAllAlpha[i]] = upperAllAlpha[idx];
                }
                lowMapping = null;
            }
            else {
                // Inline your generateCipher() logic (Fisher–Yates)
                const letters = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"];
                let currentIndex = letters.length;
                let randomIndex;

                while (currentIndex !== 0) {
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex--;
                    let tmp = letters[currentIndex];
                    letters[currentIndex] = letters[randomIndex];
                    letters[randomIndex] = tmp;
                }

                lowMapping = {};
                for (let ind = 0; ind < ALPHABET_LENGTH; ind++) {
                    lowMapping[alphabet[ind]] = letters[ind];
                }

                currentCipher = {};
                for (let i = 0; i < 26; i++) {
                    const l = alphabet[i];
                    const u = upperAllAlpha[i];
                    const mappedLo = lowMapping[l];
                    if (mappedLo) {
                        currentCipher[u] = mappedLo.toUpperCase();
                    } else {
                        currentCipher[u] = up;
                    }
                }
            }

            updateDisplay();
        }

        // Load (validates and sets both tiles and your lowercase map)
        function loadCipher() {
            const txt = document.querySelector("#loadInput").value;
            let str = "";
            if (typeof txt === "string") {
                str = txt.toUpperCase();
            }

            const error = document.querySelector("#error");
            if (str.length !== 26) {
                error.textContent = "Invalid cipher mapping";
                return;
            }
            const unique = new Set(str);
            if (unique.size !== 26) {
                error.textContent = "Invalid cipher mapping";
                return;
            }
            const nonAZ = /[^A-Z]/.test(str);
            if (nonAZ) {
                error.textContent = "Invalid cipher mapping";
                return;
            }
            error.textContent = "";

            currentCipher = {};
            for (let i = 0; i < 26; i++) {
                currentCipher[upperAllAlpha[i]] = str[i];
            }

            lowMapping = {};
            for (let i = 0; i < 26; i++) {
                lowMapping[alphabet[i]] = str[i].toLowerCase();
            }

            updateDisplay();
        }

        // Transform (directly embeds your Caesar/Substitution encode/decode loops)
        function transform(text, encrypt = true) {
            const type = document.querySelector("#chosenCiph").value;

            if (type === "caesar") {
                let shift = parseInt(document.querySelector("#shift").value, 10);
                if (isNaN(shift)) {
                    shift = 0;
                }

                if (encrypt === true) {
                    // your caesarCipher(message, shift)
                    let resStr = "";
                    for(let ind = 0; ind < text.length; ind++){
                        if(isCapitalLetter(text[ind]))
                        {
                            let initIndex = alphabet.indexOf(text[ind].toLowerCase());
                            let finalindex = shiftLogic(initIndex, shift);
                            resStr += returnCapitalLetter(alphabet[finalindex]);
                            continue;
                        }
                        else if(isLowercaseLetter(text[ind]))
                        {
                            let initIndex = alphabet.indexOf(text[ind]);
                            let finalindex = shiftLogic(initIndex, shift);
                            resStr += alphabet[finalindex];
                        }
                        else{
                            resStr += text[ind];
                        }
                    }
                    return resStr;
                }
                else {
                   
                    let resStr = "";
                    for(let ind = 0; ind < text.length; ind++){
                        if(isCapitalLetter(text[ind]))
                        {
                            let initIndex = alphabet.indexOf(text[ind].toLowerCase());
                            let finalindex = shiftLogic(initIndex, -shift);
                            resStr += returnCapitalLetter(alphabet[finalindex]);
                            continue;
                        }
                        else if(isLowercaseLetter(text[ind]))
                        {
                            let initIndex = alphabet.indexOf(text[ind]);
                            let finalindex = shiftLogic(initIndex, -shift);
                            resStr += alphabet[finalindex];
                        }
                        else{
                            resStr += text[ind];
                        }
                    }
                    return resStr;
                }
            }
            else {
                // ensure lowercase map exists from tiles if not generated/loaded
                if (!lowMapping) {
                    lowMapping = {};
                    for (let i = 0; i < 26; i++) {
                        const upFrom = upperAllAlpha[i];
                        const upTo = currentCipher[upFrom];
                        if (upTo) {
                            lowMapping[alphabet[i]] = upTo.toLowerCase();
                        } else {
                            lowMapping[alphabet[i]] = upFrom.toLowerCase();
                        }
                    }
                }

                if (encrypt === true) {
                    // your substitutionCipher(message, cipherMap)
                    let resStr = "";
                    for(let ind = 0; ind < text.length; ind++){
                        if(isCapitalLetter(text[ind]))
                        {
                            let lowerChar = text[ind].toLowerCase();
                            let inCipher = lowMapping[lowerChar];
                            if(inCipher)
                            {
                                resStr += returnCapitalLetter(inCipher);
                            }
                            else
                            {
                                resStr += text[ind];
                            }
                            continue;
                        }
                        else if(isLowercaseLetter(text[ind]))
                        {
                            let inCipher = lowMapping[text[ind]];
                            if(inCipher)
                            {
                                resStr += inCipher;
                            }
                            else
                            {
                                resStr += text[ind];
                            }
                        }
                        else
                        {
                            resStr += text[ind];
                        }
                    }
                    return resStr;
                }
                else {
                    // your substitutionDecode(message, cipherMap)
                    let resStr = "";
                    for(let ind = 0; ind < text.length; ind++){
                        if(isCapitalLetter(text[ind]))
                        {
                            let lowerChar = text[ind].toLowerCase();
                            let start = getOriginalValue(lowMapping, lowerChar);
                            if(start){
                                resStr += returnCapitalLetter(start);
                            }
                            else{
                                resStr += text[ind];
                            }
                            continue;
                        }
                        else if(isLowercaseLetter(text[ind]))
                        {
                            let start = getOriginalValue(lowMapping, text[ind]);
                            if(start){
                                resStr += start;
                            }
                            else{
                                resStr += text[ind];
                            }
                        }
                        else{
                            resStr += text[ind];
                        }
                    }
                    return resStr;
                }
            }
        }

        // ===== exact event wiring you wanted to keep =====
        document.querySelector("#genBtn").onclick = generateCipher;
        document.querySelector("#loadBtn").onclick = loadCipher;
        document.querySelector("#encBtn").onclick = () => {
            document.querySelector("#answer").value =
                transform(document.querySelector("#plain").value, true);
        };
        document.querySelector("#decBtn").onclick = () => {
            document.querySelector("#answer").value =
                transform(document.querySelector("#plain").value, false);
        };

        generateCipher();
    </script>
</body>
</html>
